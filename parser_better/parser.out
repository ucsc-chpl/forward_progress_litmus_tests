Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ELSE
    IGNORE
    LBRACE
    RBRACE

Grammar

Rule 0     S' -> program
Rule 1     program -> threads
Rule 2     threads -> thread threads
Rule 3     threads -> thread
Rule 4     thread -> THREAD NUM statement_list
Rule 5     statement_list -> PC statement statement_list
Rule 6     statement_list -> PC statement
Rule 7     statement -> simple_stmts
Rule 8     statement -> compound_stmt
Rule 9     simple_stmts -> simple_stmt SEMI
Rule 10    simple_stmt -> assign
Rule 11    simple_stmt -> goto_stmt
Rule 12    compound_stmt -> if_stmt
Rule 13    compound_stmt -> <empty>
Rule 14    assign -> rhs ASSIGN expr
Rule 15    assign -> <empty>
Rule 16    rhs -> ID
Rule 17    rhs -> mem
Rule 18    goto_stmt -> GOTO NUM
Rule 19    expr -> expr PLUS val
Rule 20    expr -> val
Rule 21    val -> mem
Rule 22    val -> exch
Rule 23    val -> NUM
Rule 24    exch -> EXCH LPAREN mem COMMA NUM RPAREN
Rule 25    mem -> MEM LBRACK NUM RBRACK
Rule 26    compare -> expr EQUAL expr
Rule 27    compare -> expr NEQUAL expr
Rule 28    if_stmt -> IF LPAREN compare RPAREN statement
Rule 29    if_stmt -> <empty>

Terminals, with rules where they appear

ASSIGN               : 14
COMMA                : 24
ELSE                 : 
EQUAL                : 26
EXCH                 : 24
GOTO                 : 18
ID                   : 16
IF                   : 28
IGNORE               : 
LBRACE               : 
LBRACK               : 25
LPAREN               : 24 28
MEM                  : 25
NEQUAL               : 27
NUM                  : 4 18 23 24 25
PC                   : 5 6
PLUS                 : 19
RBRACE               : 
RBRACK               : 25
RPAREN               : 24 28
SEMI                 : 9
THREAD               : 4
error                : 

Nonterminals, with rules where they appear

assign               : 10
compare              : 28
compound_stmt        : 8
exch                 : 22
expr                 : 14 19 26 26 27 27
goto_stmt            : 11
if_stmt              : 12
mem                  : 17 21 24
program              : 0
rhs                  : 14
simple_stmt          : 9
simple_stmts         : 7
statement            : 5 6 28
statement_list       : 4 5
thread               : 2 3
threads              : 1 2
val                  : 19 20

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . threads
    (2) threads -> . thread threads
    (3) threads -> . thread
    (4) thread -> . THREAD NUM statement_list

    THREAD          shift and go to state 4

    program                        shift and go to state 1
    threads                        shift and go to state 2
    thread                         shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> threads .

    $end            reduce using rule 1 (program -> threads .)


state 3

    (2) threads -> thread . threads
    (3) threads -> thread .
    (2) threads -> . thread threads
    (3) threads -> . thread
    (4) thread -> . THREAD NUM statement_list

    $end            reduce using rule 3 (threads -> thread .)
    THREAD          shift and go to state 4

    thread                         shift and go to state 3
    threads                        shift and go to state 5

state 4

    (4) thread -> THREAD . NUM statement_list

    NUM             shift and go to state 6


state 5

    (2) threads -> thread threads .

    $end            reduce using rule 2 (threads -> thread threads .)


state 6

    (4) thread -> THREAD NUM . statement_list
    (5) statement_list -> . PC statement statement_list
    (6) statement_list -> . PC statement

    PC              shift and go to state 8

    statement_list                 shift and go to state 7

state 7

    (4) thread -> THREAD NUM statement_list .

    THREAD          reduce using rule 4 (thread -> THREAD NUM statement_list .)
    $end            reduce using rule 4 (thread -> THREAD NUM statement_list .)


state 8

    (5) statement_list -> PC . statement statement_list
    (6) statement_list -> PC . statement
    (7) statement -> . simple_stmts
    (8) statement -> . compound_stmt
    (9) simple_stmts -> . simple_stmt SEMI
    (12) compound_stmt -> . if_stmt
    (13) compound_stmt -> .
    (10) simple_stmt -> . assign
    (11) simple_stmt -> . goto_stmt
    (28) if_stmt -> . IF LPAREN compare RPAREN statement
    (29) if_stmt -> .
    (14) assign -> . rhs ASSIGN expr
    (15) assign -> .
    (18) goto_stmt -> . GOTO NUM
    (16) rhs -> . ID
    (17) rhs -> . mem
    (25) mem -> . MEM LBRACK NUM RBRACK

  ! reduce/reduce conflict for PC resolved using rule 13 (compound_stmt -> .)
  ! reduce/reduce conflict for THREAD resolved using rule 13 (compound_stmt -> .)
  ! reduce/reduce conflict for $end resolved using rule 13 (compound_stmt -> .)
    PC              reduce using rule 13 (compound_stmt -> .)
    THREAD          reduce using rule 13 (compound_stmt -> .)
    $end            reduce using rule 13 (compound_stmt -> .)
    IF              shift and go to state 16
    SEMI            reduce using rule 15 (assign -> .)
    GOTO            shift and go to state 18
    ID              shift and go to state 19
    MEM             shift and go to state 21

  ! PC              [ reduce using rule 29 (if_stmt -> .) ]
  ! THREAD          [ reduce using rule 29 (if_stmt -> .) ]
  ! $end            [ reduce using rule 29 (if_stmt -> .) ]

    statement                      shift and go to state 9
    simple_stmts                   shift and go to state 10
    compound_stmt                  shift and go to state 11
    simple_stmt                    shift and go to state 12
    if_stmt                        shift and go to state 13
    assign                         shift and go to state 14
    goto_stmt                      shift and go to state 15
    rhs                            shift and go to state 17
    mem                            shift and go to state 20

state 9

    (5) statement_list -> PC statement . statement_list
    (6) statement_list -> PC statement .
    (5) statement_list -> . PC statement statement_list
    (6) statement_list -> . PC statement

    THREAD          reduce using rule 6 (statement_list -> PC statement .)
    $end            reduce using rule 6 (statement_list -> PC statement .)
    PC              shift and go to state 8

    statement_list                 shift and go to state 22

state 10

    (7) statement -> simple_stmts .

    PC              reduce using rule 7 (statement -> simple_stmts .)
    THREAD          reduce using rule 7 (statement -> simple_stmts .)
    $end            reduce using rule 7 (statement -> simple_stmts .)


state 11

    (8) statement -> compound_stmt .

    PC              reduce using rule 8 (statement -> compound_stmt .)
    THREAD          reduce using rule 8 (statement -> compound_stmt .)
    $end            reduce using rule 8 (statement -> compound_stmt .)


state 12

    (9) simple_stmts -> simple_stmt . SEMI

    SEMI            shift and go to state 23


state 13

    (12) compound_stmt -> if_stmt .

    PC              reduce using rule 12 (compound_stmt -> if_stmt .)
    THREAD          reduce using rule 12 (compound_stmt -> if_stmt .)
    $end            reduce using rule 12 (compound_stmt -> if_stmt .)


state 14

    (10) simple_stmt -> assign .

    SEMI            reduce using rule 10 (simple_stmt -> assign .)


state 15

    (11) simple_stmt -> goto_stmt .

    SEMI            reduce using rule 11 (simple_stmt -> goto_stmt .)


state 16

    (28) if_stmt -> IF . LPAREN compare RPAREN statement

    LPAREN          shift and go to state 24


state 17

    (14) assign -> rhs . ASSIGN expr

    ASSIGN          shift and go to state 25


state 18

    (18) goto_stmt -> GOTO . NUM

    NUM             shift and go to state 26


state 19

    (16) rhs -> ID .

    ASSIGN          reduce using rule 16 (rhs -> ID .)


state 20

    (17) rhs -> mem .

    ASSIGN          reduce using rule 17 (rhs -> mem .)


state 21

    (25) mem -> MEM . LBRACK NUM RBRACK

    LBRACK          shift and go to state 27


state 22

    (5) statement_list -> PC statement statement_list .

    THREAD          reduce using rule 5 (statement_list -> PC statement statement_list .)
    $end            reduce using rule 5 (statement_list -> PC statement statement_list .)


state 23

    (9) simple_stmts -> simple_stmt SEMI .

    PC              reduce using rule 9 (simple_stmts -> simple_stmt SEMI .)
    THREAD          reduce using rule 9 (simple_stmts -> simple_stmt SEMI .)
    $end            reduce using rule 9 (simple_stmts -> simple_stmt SEMI .)


state 24

    (28) if_stmt -> IF LPAREN . compare RPAREN statement
    (26) compare -> . expr EQUAL expr
    (27) compare -> . expr NEQUAL expr
    (19) expr -> . expr PLUS val
    (20) expr -> . val
    (21) val -> . mem
    (22) val -> . exch
    (23) val -> . NUM
    (25) mem -> . MEM LBRACK NUM RBRACK
    (24) exch -> . EXCH LPAREN mem COMMA NUM RPAREN

    NUM             shift and go to state 33
    MEM             shift and go to state 21
    EXCH            shift and go to state 34

    compare                        shift and go to state 28
    expr                           shift and go to state 29
    val                            shift and go to state 30
    mem                            shift and go to state 31
    exch                           shift and go to state 32

state 25

    (14) assign -> rhs ASSIGN . expr
    (19) expr -> . expr PLUS val
    (20) expr -> . val
    (21) val -> . mem
    (22) val -> . exch
    (23) val -> . NUM
    (25) mem -> . MEM LBRACK NUM RBRACK
    (24) exch -> . EXCH LPAREN mem COMMA NUM RPAREN

    NUM             shift and go to state 33
    MEM             shift and go to state 21
    EXCH            shift and go to state 34

    expr                           shift and go to state 35
    val                            shift and go to state 30
    mem                            shift and go to state 31
    exch                           shift and go to state 32

state 26

    (18) goto_stmt -> GOTO NUM .

    SEMI            reduce using rule 18 (goto_stmt -> GOTO NUM .)


state 27

    (25) mem -> MEM LBRACK . NUM RBRACK

    NUM             shift and go to state 36


state 28

    (28) if_stmt -> IF LPAREN compare . RPAREN statement

    RPAREN          shift and go to state 37


state 29

    (26) compare -> expr . EQUAL expr
    (27) compare -> expr . NEQUAL expr
    (19) expr -> expr . PLUS val

    EQUAL           shift and go to state 38
    NEQUAL          shift and go to state 39
    PLUS            shift and go to state 40


state 30

    (20) expr -> val .

    EQUAL           reduce using rule 20 (expr -> val .)
    NEQUAL          reduce using rule 20 (expr -> val .)
    PLUS            reduce using rule 20 (expr -> val .)
    SEMI            reduce using rule 20 (expr -> val .)
    RPAREN          reduce using rule 20 (expr -> val .)


state 31

    (21) val -> mem .

    EQUAL           reduce using rule 21 (val -> mem .)
    NEQUAL          reduce using rule 21 (val -> mem .)
    PLUS            reduce using rule 21 (val -> mem .)
    SEMI            reduce using rule 21 (val -> mem .)
    RPAREN          reduce using rule 21 (val -> mem .)


state 32

    (22) val -> exch .

    EQUAL           reduce using rule 22 (val -> exch .)
    NEQUAL          reduce using rule 22 (val -> exch .)
    PLUS            reduce using rule 22 (val -> exch .)
    SEMI            reduce using rule 22 (val -> exch .)
    RPAREN          reduce using rule 22 (val -> exch .)


state 33

    (23) val -> NUM .

    EQUAL           reduce using rule 23 (val -> NUM .)
    NEQUAL          reduce using rule 23 (val -> NUM .)
    PLUS            reduce using rule 23 (val -> NUM .)
    SEMI            reduce using rule 23 (val -> NUM .)
    RPAREN          reduce using rule 23 (val -> NUM .)


state 34

    (24) exch -> EXCH . LPAREN mem COMMA NUM RPAREN

    LPAREN          shift and go to state 41


state 35

    (14) assign -> rhs ASSIGN expr .
    (19) expr -> expr . PLUS val

    SEMI            reduce using rule 14 (assign -> rhs ASSIGN expr .)
    PLUS            shift and go to state 40


state 36

    (25) mem -> MEM LBRACK NUM . RBRACK

    RBRACK          shift and go to state 42


state 37

    (28) if_stmt -> IF LPAREN compare RPAREN . statement
    (7) statement -> . simple_stmts
    (8) statement -> . compound_stmt
    (9) simple_stmts -> . simple_stmt SEMI
    (12) compound_stmt -> . if_stmt
    (13) compound_stmt -> .
    (10) simple_stmt -> . assign
    (11) simple_stmt -> . goto_stmt
    (28) if_stmt -> . IF LPAREN compare RPAREN statement
    (29) if_stmt -> .
    (14) assign -> . rhs ASSIGN expr
    (15) assign -> .
    (18) goto_stmt -> . GOTO NUM
    (16) rhs -> . ID
    (17) rhs -> . mem
    (25) mem -> . MEM LBRACK NUM RBRACK

  ! reduce/reduce conflict for PC resolved using rule 13 (compound_stmt -> .)
  ! reduce/reduce conflict for THREAD resolved using rule 13 (compound_stmt -> .)
  ! reduce/reduce conflict for $end resolved using rule 13 (compound_stmt -> .)
    PC              reduce using rule 13 (compound_stmt -> .)
    THREAD          reduce using rule 13 (compound_stmt -> .)
    $end            reduce using rule 13 (compound_stmt -> .)
    IF              shift and go to state 16
    SEMI            reduce using rule 15 (assign -> .)
    GOTO            shift and go to state 18
    ID              shift and go to state 19
    MEM             shift and go to state 21

  ! PC              [ reduce using rule 29 (if_stmt -> .) ]
  ! THREAD          [ reduce using rule 29 (if_stmt -> .) ]
  ! $end            [ reduce using rule 29 (if_stmt -> .) ]

    statement                      shift and go to state 43
    simple_stmts                   shift and go to state 10
    compound_stmt                  shift and go to state 11
    simple_stmt                    shift and go to state 12
    if_stmt                        shift and go to state 13
    assign                         shift and go to state 14
    goto_stmt                      shift and go to state 15
    rhs                            shift and go to state 17
    mem                            shift and go to state 20

state 38

    (26) compare -> expr EQUAL . expr
    (19) expr -> . expr PLUS val
    (20) expr -> . val
    (21) val -> . mem
    (22) val -> . exch
    (23) val -> . NUM
    (25) mem -> . MEM LBRACK NUM RBRACK
    (24) exch -> . EXCH LPAREN mem COMMA NUM RPAREN

    NUM             shift and go to state 33
    MEM             shift and go to state 21
    EXCH            shift and go to state 34

    expr                           shift and go to state 44
    val                            shift and go to state 30
    mem                            shift and go to state 31
    exch                           shift and go to state 32

state 39

    (27) compare -> expr NEQUAL . expr
    (19) expr -> . expr PLUS val
    (20) expr -> . val
    (21) val -> . mem
    (22) val -> . exch
    (23) val -> . NUM
    (25) mem -> . MEM LBRACK NUM RBRACK
    (24) exch -> . EXCH LPAREN mem COMMA NUM RPAREN

    NUM             shift and go to state 33
    MEM             shift and go to state 21
    EXCH            shift and go to state 34

    expr                           shift and go to state 45
    val                            shift and go to state 30
    mem                            shift and go to state 31
    exch                           shift and go to state 32

state 40

    (19) expr -> expr PLUS . val
    (21) val -> . mem
    (22) val -> . exch
    (23) val -> . NUM
    (25) mem -> . MEM LBRACK NUM RBRACK
    (24) exch -> . EXCH LPAREN mem COMMA NUM RPAREN

    NUM             shift and go to state 33
    MEM             shift and go to state 21
    EXCH            shift and go to state 34

    val                            shift and go to state 46
    mem                            shift and go to state 31
    exch                           shift and go to state 32

state 41

    (24) exch -> EXCH LPAREN . mem COMMA NUM RPAREN
    (25) mem -> . MEM LBRACK NUM RBRACK

    MEM             shift and go to state 21

    mem                            shift and go to state 47

state 42

    (25) mem -> MEM LBRACK NUM RBRACK .

    ASSIGN          reduce using rule 25 (mem -> MEM LBRACK NUM RBRACK .)
    EQUAL           reduce using rule 25 (mem -> MEM LBRACK NUM RBRACK .)
    NEQUAL          reduce using rule 25 (mem -> MEM LBRACK NUM RBRACK .)
    PLUS            reduce using rule 25 (mem -> MEM LBRACK NUM RBRACK .)
    SEMI            reduce using rule 25 (mem -> MEM LBRACK NUM RBRACK .)
    RPAREN          reduce using rule 25 (mem -> MEM LBRACK NUM RBRACK .)
    COMMA           reduce using rule 25 (mem -> MEM LBRACK NUM RBRACK .)


state 43

    (28) if_stmt -> IF LPAREN compare RPAREN statement .

    PC              reduce using rule 28 (if_stmt -> IF LPAREN compare RPAREN statement .)
    THREAD          reduce using rule 28 (if_stmt -> IF LPAREN compare RPAREN statement .)
    $end            reduce using rule 28 (if_stmt -> IF LPAREN compare RPAREN statement .)


state 44

    (26) compare -> expr EQUAL expr .
    (19) expr -> expr . PLUS val

    RPAREN          reduce using rule 26 (compare -> expr EQUAL expr .)
    PLUS            shift and go to state 40


state 45

    (27) compare -> expr NEQUAL expr .
    (19) expr -> expr . PLUS val

    RPAREN          reduce using rule 27 (compare -> expr NEQUAL expr .)
    PLUS            shift and go to state 40


state 46

    (19) expr -> expr PLUS val .

    EQUAL           reduce using rule 19 (expr -> expr PLUS val .)
    NEQUAL          reduce using rule 19 (expr -> expr PLUS val .)
    PLUS            reduce using rule 19 (expr -> expr PLUS val .)
    SEMI            reduce using rule 19 (expr -> expr PLUS val .)
    RPAREN          reduce using rule 19 (expr -> expr PLUS val .)


state 47

    (24) exch -> EXCH LPAREN mem . COMMA NUM RPAREN

    COMMA           shift and go to state 48


state 48

    (24) exch -> EXCH LPAREN mem COMMA . NUM RPAREN

    NUM             shift and go to state 49


state 49

    (24) exch -> EXCH LPAREN mem COMMA NUM . RPAREN

    RPAREN          shift and go to state 50


state 50

    (24) exch -> EXCH LPAREN mem COMMA NUM RPAREN .

    EQUAL           reduce using rule 24 (exch -> EXCH LPAREN mem COMMA NUM RPAREN .)
    NEQUAL          reduce using rule 24 (exch -> EXCH LPAREN mem COMMA NUM RPAREN .)
    PLUS            reduce using rule 24 (exch -> EXCH LPAREN mem COMMA NUM RPAREN .)
    SEMI            reduce using rule 24 (exch -> EXCH LPAREN mem COMMA NUM RPAREN .)
    RPAREN          reduce using rule 24 (exch -> EXCH LPAREN mem COMMA NUM RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 8 resolved using rule (compound_stmt -> <empty>)
WARNING: rejected rule (if_stmt -> <empty>) in state 8
WARNING: reduce/reduce conflict in state 37 resolved using rule (compound_stmt -> <empty>)
WARNING: rejected rule (if_stmt -> <empty>) in state 37
WARNING: Rule (if_stmt -> <empty>) is never reduced
