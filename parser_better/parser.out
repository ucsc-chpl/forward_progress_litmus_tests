Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ELSE
    IGNORE
    LBRACE
    RBRACE

Grammar

Rule 0     S' -> program
Rule 1     program -> threads
Rule 2     threads -> thread threads
Rule 3     threads -> thread
Rule 4     thread -> THREAD NUM statement_list
Rule 5     statement_list -> PC statement statement_list
Rule 6     statement_list -> PC statement
Rule 7     statement -> simple_stmts
Rule 8     statement -> if_stmt
Rule 9     simple_stmts -> simple_stmt SEMI
Rule 10    simple_stmt -> assign
Rule 11    simple_stmt -> goto_stmt
Rule 12    assign -> rhs ASSIGN expr
Rule 13    assign -> <empty>
Rule 14    rhs -> ID
Rule 15    rhs -> mem
Rule 16    goto_stmt -> GOTO NUM
Rule 17    expr -> expr PLUS val
Rule 18    expr -> val
Rule 19    val -> mem
Rule 20    val -> exch
Rule 21    val -> NUM
Rule 22    exch -> EXCH LPAREN mem COMMA NUM RPAREN
Rule 23    mem -> MEM LBRACK NUM RBRACK
Rule 24    compare -> expr EQUAL expr
Rule 25    compare -> expr NEQUAL expr
Rule 26    if_stmt -> IF LPAREN compare RPAREN statement
Rule 27    if_stmt -> <empty>

Terminals, with rules where they appear

ASSIGN               : 12
COMMA                : 22
ELSE                 : 
EQUAL                : 24
EXCH                 : 22
GOTO                 : 16
ID                   : 14
IF                   : 26
IGNORE               : 
LBRACE               : 
LBRACK               : 23
LPAREN               : 22 26
MEM                  : 23
NEQUAL               : 25
NUM                  : 4 16 21 22 23
PC                   : 5 6
PLUS                 : 17
RBRACE               : 
RBRACK               : 23
RPAREN               : 22 26
SEMI                 : 9
THREAD               : 4
error                : 

Nonterminals, with rules where they appear

assign               : 10
compare              : 26
exch                 : 20
expr                 : 12 17 24 24 25 25
goto_stmt            : 11
if_stmt              : 8
mem                  : 15 19 22
program              : 0
rhs                  : 12
simple_stmt          : 9
simple_stmts         : 7
statement            : 5 6 26
statement_list       : 4 5
thread               : 2 3
threads              : 1 2
val                  : 17 18

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . threads
    (2) threads -> . thread threads
    (3) threads -> . thread
    (4) thread -> . THREAD NUM statement_list

    THREAD          shift and go to state 4

    program                        shift and go to state 1
    threads                        shift and go to state 2
    thread                         shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> threads .

    $end            reduce using rule 1 (program -> threads .)


state 3

    (2) threads -> thread . threads
    (3) threads -> thread .
    (2) threads -> . thread threads
    (3) threads -> . thread
    (4) thread -> . THREAD NUM statement_list

    $end            reduce using rule 3 (threads -> thread .)
    THREAD          shift and go to state 4

    thread                         shift and go to state 3
    threads                        shift and go to state 5

state 4

    (4) thread -> THREAD . NUM statement_list

    NUM             shift and go to state 6


state 5

    (2) threads -> thread threads .

    $end            reduce using rule 2 (threads -> thread threads .)


state 6

    (4) thread -> THREAD NUM . statement_list
    (5) statement_list -> . PC statement statement_list
    (6) statement_list -> . PC statement

    PC              shift and go to state 8

    statement_list                 shift and go to state 7

state 7

    (4) thread -> THREAD NUM statement_list .

    THREAD          reduce using rule 4 (thread -> THREAD NUM statement_list .)
    $end            reduce using rule 4 (thread -> THREAD NUM statement_list .)


state 8

    (5) statement_list -> PC . statement statement_list
    (6) statement_list -> PC . statement
    (7) statement -> . simple_stmts
    (8) statement -> . if_stmt
    (9) simple_stmts -> . simple_stmt SEMI
    (26) if_stmt -> . IF LPAREN compare RPAREN statement
    (27) if_stmt -> .
    (10) simple_stmt -> . assign
    (11) simple_stmt -> . goto_stmt
    (12) assign -> . rhs ASSIGN expr
    (13) assign -> .
    (16) goto_stmt -> . GOTO NUM
    (14) rhs -> . ID
    (15) rhs -> . mem
    (23) mem -> . MEM LBRACK NUM RBRACK

    IF              shift and go to state 13
    PC              reduce using rule 27 (if_stmt -> .)
    THREAD          reduce using rule 27 (if_stmt -> .)
    $end            reduce using rule 27 (if_stmt -> .)
    SEMI            reduce using rule 13 (assign -> .)
    GOTO            shift and go to state 17
    ID              shift and go to state 18
    MEM             shift and go to state 20

    statement                      shift and go to state 9
    simple_stmts                   shift and go to state 10
    if_stmt                        shift and go to state 11
    simple_stmt                    shift and go to state 12
    assign                         shift and go to state 14
    goto_stmt                      shift and go to state 15
    rhs                            shift and go to state 16
    mem                            shift and go to state 19

state 9

    (5) statement_list -> PC statement . statement_list
    (6) statement_list -> PC statement .
    (5) statement_list -> . PC statement statement_list
    (6) statement_list -> . PC statement

    THREAD          reduce using rule 6 (statement_list -> PC statement .)
    $end            reduce using rule 6 (statement_list -> PC statement .)
    PC              shift and go to state 8

    statement_list                 shift and go to state 21

state 10

    (7) statement -> simple_stmts .

    PC              reduce using rule 7 (statement -> simple_stmts .)
    THREAD          reduce using rule 7 (statement -> simple_stmts .)
    $end            reduce using rule 7 (statement -> simple_stmts .)


state 11

    (8) statement -> if_stmt .

    PC              reduce using rule 8 (statement -> if_stmt .)
    THREAD          reduce using rule 8 (statement -> if_stmt .)
    $end            reduce using rule 8 (statement -> if_stmt .)


state 12

    (9) simple_stmts -> simple_stmt . SEMI

    SEMI            shift and go to state 22


state 13

    (26) if_stmt -> IF . LPAREN compare RPAREN statement

    LPAREN          shift and go to state 23


state 14

    (10) simple_stmt -> assign .

    SEMI            reduce using rule 10 (simple_stmt -> assign .)


state 15

    (11) simple_stmt -> goto_stmt .

    SEMI            reduce using rule 11 (simple_stmt -> goto_stmt .)


state 16

    (12) assign -> rhs . ASSIGN expr

    ASSIGN          shift and go to state 24


state 17

    (16) goto_stmt -> GOTO . NUM

    NUM             shift and go to state 25


state 18

    (14) rhs -> ID .

    ASSIGN          reduce using rule 14 (rhs -> ID .)


state 19

    (15) rhs -> mem .

    ASSIGN          reduce using rule 15 (rhs -> mem .)


state 20

    (23) mem -> MEM . LBRACK NUM RBRACK

    LBRACK          shift and go to state 26


state 21

    (5) statement_list -> PC statement statement_list .

    THREAD          reduce using rule 5 (statement_list -> PC statement statement_list .)
    $end            reduce using rule 5 (statement_list -> PC statement statement_list .)


state 22

    (9) simple_stmts -> simple_stmt SEMI .

    PC              reduce using rule 9 (simple_stmts -> simple_stmt SEMI .)
    THREAD          reduce using rule 9 (simple_stmts -> simple_stmt SEMI .)
    $end            reduce using rule 9 (simple_stmts -> simple_stmt SEMI .)


state 23

    (26) if_stmt -> IF LPAREN . compare RPAREN statement
    (24) compare -> . expr EQUAL expr
    (25) compare -> . expr NEQUAL expr
    (17) expr -> . expr PLUS val
    (18) expr -> . val
    (19) val -> . mem
    (20) val -> . exch
    (21) val -> . NUM
    (23) mem -> . MEM LBRACK NUM RBRACK
    (22) exch -> . EXCH LPAREN mem COMMA NUM RPAREN

    NUM             shift and go to state 32
    MEM             shift and go to state 20
    EXCH            shift and go to state 33

    compare                        shift and go to state 27
    expr                           shift and go to state 28
    val                            shift and go to state 29
    mem                            shift and go to state 30
    exch                           shift and go to state 31

state 24

    (12) assign -> rhs ASSIGN . expr
    (17) expr -> . expr PLUS val
    (18) expr -> . val
    (19) val -> . mem
    (20) val -> . exch
    (21) val -> . NUM
    (23) mem -> . MEM LBRACK NUM RBRACK
    (22) exch -> . EXCH LPAREN mem COMMA NUM RPAREN

    NUM             shift and go to state 32
    MEM             shift and go to state 20
    EXCH            shift and go to state 33

    expr                           shift and go to state 34
    val                            shift and go to state 29
    mem                            shift and go to state 30
    exch                           shift and go to state 31

state 25

    (16) goto_stmt -> GOTO NUM .

    SEMI            reduce using rule 16 (goto_stmt -> GOTO NUM .)


state 26

    (23) mem -> MEM LBRACK . NUM RBRACK

    NUM             shift and go to state 35


state 27

    (26) if_stmt -> IF LPAREN compare . RPAREN statement

    RPAREN          shift and go to state 36


state 28

    (24) compare -> expr . EQUAL expr
    (25) compare -> expr . NEQUAL expr
    (17) expr -> expr . PLUS val

    EQUAL           shift and go to state 37
    NEQUAL          shift and go to state 38
    PLUS            shift and go to state 39


state 29

    (18) expr -> val .

    EQUAL           reduce using rule 18 (expr -> val .)
    NEQUAL          reduce using rule 18 (expr -> val .)
    PLUS            reduce using rule 18 (expr -> val .)
    SEMI            reduce using rule 18 (expr -> val .)
    RPAREN          reduce using rule 18 (expr -> val .)


state 30

    (19) val -> mem .

    EQUAL           reduce using rule 19 (val -> mem .)
    NEQUAL          reduce using rule 19 (val -> mem .)
    PLUS            reduce using rule 19 (val -> mem .)
    SEMI            reduce using rule 19 (val -> mem .)
    RPAREN          reduce using rule 19 (val -> mem .)


state 31

    (20) val -> exch .

    EQUAL           reduce using rule 20 (val -> exch .)
    NEQUAL          reduce using rule 20 (val -> exch .)
    PLUS            reduce using rule 20 (val -> exch .)
    SEMI            reduce using rule 20 (val -> exch .)
    RPAREN          reduce using rule 20 (val -> exch .)


state 32

    (21) val -> NUM .

    EQUAL           reduce using rule 21 (val -> NUM .)
    NEQUAL          reduce using rule 21 (val -> NUM .)
    PLUS            reduce using rule 21 (val -> NUM .)
    SEMI            reduce using rule 21 (val -> NUM .)
    RPAREN          reduce using rule 21 (val -> NUM .)


state 33

    (22) exch -> EXCH . LPAREN mem COMMA NUM RPAREN

    LPAREN          shift and go to state 40


state 34

    (12) assign -> rhs ASSIGN expr .
    (17) expr -> expr . PLUS val

    SEMI            reduce using rule 12 (assign -> rhs ASSIGN expr .)
    PLUS            shift and go to state 39


state 35

    (23) mem -> MEM LBRACK NUM . RBRACK

    RBRACK          shift and go to state 41


state 36

    (26) if_stmt -> IF LPAREN compare RPAREN . statement
    (7) statement -> . simple_stmts
    (8) statement -> . if_stmt
    (9) simple_stmts -> . simple_stmt SEMI
    (26) if_stmt -> . IF LPAREN compare RPAREN statement
    (27) if_stmt -> .
    (10) simple_stmt -> . assign
    (11) simple_stmt -> . goto_stmt
    (12) assign -> . rhs ASSIGN expr
    (13) assign -> .
    (16) goto_stmt -> . GOTO NUM
    (14) rhs -> . ID
    (15) rhs -> . mem
    (23) mem -> . MEM LBRACK NUM RBRACK

    IF              shift and go to state 13
    PC              reduce using rule 27 (if_stmt -> .)
    THREAD          reduce using rule 27 (if_stmt -> .)
    $end            reduce using rule 27 (if_stmt -> .)
    SEMI            reduce using rule 13 (assign -> .)
    GOTO            shift and go to state 17
    ID              shift and go to state 18
    MEM             shift and go to state 20

    statement                      shift and go to state 42
    simple_stmts                   shift and go to state 10
    if_stmt                        shift and go to state 11
    simple_stmt                    shift and go to state 12
    assign                         shift and go to state 14
    goto_stmt                      shift and go to state 15
    rhs                            shift and go to state 16
    mem                            shift and go to state 19

state 37

    (24) compare -> expr EQUAL . expr
    (17) expr -> . expr PLUS val
    (18) expr -> . val
    (19) val -> . mem
    (20) val -> . exch
    (21) val -> . NUM
    (23) mem -> . MEM LBRACK NUM RBRACK
    (22) exch -> . EXCH LPAREN mem COMMA NUM RPAREN

    NUM             shift and go to state 32
    MEM             shift and go to state 20
    EXCH            shift and go to state 33

    expr                           shift and go to state 43
    val                            shift and go to state 29
    mem                            shift and go to state 30
    exch                           shift and go to state 31

state 38

    (25) compare -> expr NEQUAL . expr
    (17) expr -> . expr PLUS val
    (18) expr -> . val
    (19) val -> . mem
    (20) val -> . exch
    (21) val -> . NUM
    (23) mem -> . MEM LBRACK NUM RBRACK
    (22) exch -> . EXCH LPAREN mem COMMA NUM RPAREN

    NUM             shift and go to state 32
    MEM             shift and go to state 20
    EXCH            shift and go to state 33

    expr                           shift and go to state 44
    val                            shift and go to state 29
    mem                            shift and go to state 30
    exch                           shift and go to state 31

state 39

    (17) expr -> expr PLUS . val
    (19) val -> . mem
    (20) val -> . exch
    (21) val -> . NUM
    (23) mem -> . MEM LBRACK NUM RBRACK
    (22) exch -> . EXCH LPAREN mem COMMA NUM RPAREN

    NUM             shift and go to state 32
    MEM             shift and go to state 20
    EXCH            shift and go to state 33

    val                            shift and go to state 45
    mem                            shift and go to state 30
    exch                           shift and go to state 31

state 40

    (22) exch -> EXCH LPAREN . mem COMMA NUM RPAREN
    (23) mem -> . MEM LBRACK NUM RBRACK

    MEM             shift and go to state 20

    mem                            shift and go to state 46

state 41

    (23) mem -> MEM LBRACK NUM RBRACK .

    ASSIGN          reduce using rule 23 (mem -> MEM LBRACK NUM RBRACK .)
    EQUAL           reduce using rule 23 (mem -> MEM LBRACK NUM RBRACK .)
    NEQUAL          reduce using rule 23 (mem -> MEM LBRACK NUM RBRACK .)
    PLUS            reduce using rule 23 (mem -> MEM LBRACK NUM RBRACK .)
    SEMI            reduce using rule 23 (mem -> MEM LBRACK NUM RBRACK .)
    RPAREN          reduce using rule 23 (mem -> MEM LBRACK NUM RBRACK .)
    COMMA           reduce using rule 23 (mem -> MEM LBRACK NUM RBRACK .)


state 42

    (26) if_stmt -> IF LPAREN compare RPAREN statement .

    PC              reduce using rule 26 (if_stmt -> IF LPAREN compare RPAREN statement .)
    THREAD          reduce using rule 26 (if_stmt -> IF LPAREN compare RPAREN statement .)
    $end            reduce using rule 26 (if_stmt -> IF LPAREN compare RPAREN statement .)


state 43

    (24) compare -> expr EQUAL expr .
    (17) expr -> expr . PLUS val

    RPAREN          reduce using rule 24 (compare -> expr EQUAL expr .)
    PLUS            shift and go to state 39


state 44

    (25) compare -> expr NEQUAL expr .
    (17) expr -> expr . PLUS val

    RPAREN          reduce using rule 25 (compare -> expr NEQUAL expr .)
    PLUS            shift and go to state 39


state 45

    (17) expr -> expr PLUS val .

    EQUAL           reduce using rule 17 (expr -> expr PLUS val .)
    NEQUAL          reduce using rule 17 (expr -> expr PLUS val .)
    PLUS            reduce using rule 17 (expr -> expr PLUS val .)
    SEMI            reduce using rule 17 (expr -> expr PLUS val .)
    RPAREN          reduce using rule 17 (expr -> expr PLUS val .)


state 46

    (22) exch -> EXCH LPAREN mem . COMMA NUM RPAREN

    COMMA           shift and go to state 47


state 47

    (22) exch -> EXCH LPAREN mem COMMA . NUM RPAREN

    NUM             shift and go to state 48


state 48

    (22) exch -> EXCH LPAREN mem COMMA NUM . RPAREN

    RPAREN          shift and go to state 49


state 49

    (22) exch -> EXCH LPAREN mem COMMA NUM RPAREN .

    EQUAL           reduce using rule 22 (exch -> EXCH LPAREN mem COMMA NUM RPAREN .)
    NEQUAL          reduce using rule 22 (exch -> EXCH LPAREN mem COMMA NUM RPAREN .)
    PLUS            reduce using rule 22 (exch -> EXCH LPAREN mem COMMA NUM RPAREN .)
    SEMI            reduce using rule 22 (exch -> EXCH LPAREN mem COMMA NUM RPAREN .)
    RPAREN          reduce using rule 22 (exch -> EXCH LPAREN mem COMMA NUM RPAREN .)

